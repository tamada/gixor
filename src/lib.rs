use std::{
    fmt::Display,
    io::BufRead,
    path::{Path, PathBuf},
};

use clap::{Parser, ValueEnum};
use serde::{Deserialize, Serialize};

mod git;
mod utils;

pub type Result<T> = std::result::Result<T, GixorError>;

#[derive(Parser, Debug, ValueEnum, Clone)]
pub enum LogLevel {
    Trace,
    Debug,
    Info,
    Warn,
    Error,
}

#[derive(Debug)]
pub enum GixorError {
    Array(Vec<GixorError>),
    Git(git2::Error),
    IO(std::io::Error),
    Json(serde_json::Error),
    Fatal(String),
    NotFound(String),
}

impl Display for GixorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GixorError::Array(errs) => {
                let result = errs.iter().map(|e| e.fmt(f)).collect::<Vec<_>>();
                if result.iter().any(|r| r.is_err()) {
                    Err(std::fmt::Error)
                } else {
                    Ok(())
                }
            }
            GixorError::NotFound(name) => write!(f, "{}: not found", name),
            GixorError::Git(e) => write!(f, "Git error: {}", e),
            GixorError::IO(e) => write!(f, "IO error: {}", e),
            GixorError::Json(e) => write!(f, "JSON error: {}", e),
            GixorError::Fatal(msg) => write!(f, "Fatal error: {}", msg),
        }
    }
}

pub struct Boilerplate<'a> {
    pub(crate) name: String,
    pub(crate) path: PathBuf,
    repo: &'a Repository,
    base_path: PathBuf,
}

impl<'a> Boilerplate<'a> {
    pub fn new(name: String, path: PathBuf, repo: &'a Repository, base_path: &Path) -> Boilerplate<'a> {
        Boilerplate { name, path, repo, base_path: base_path.to_path_buf() }
    }

    pub fn dump(&self) -> Result<String> {
        let hash = self.repo.hash(&self.base_path)?;
        let content = dump_path(self.path.clone())?;
        log::info!("hash: {:02x?}", hash);
        let hash_string = hash
            .iter()
            .map(|data| format!("{:02x}", data))
            .collect::<String>();
        Ok(format!(
            r#"### Generated by Gixor (https://github.com/tamada/gixor)
### https://raw.github.com/{}/{}/{}/{}
{}
"#,
            self.repo.owner,
            self.repo.repo_name,
            hash_string,
            to_relative_path(&self.path, self.base_path.join(&self.repo.name)),
            content
        ))
    }
}

fn to_relative_path(path: &PathBuf, base_path: PathBuf) -> String {
    let relative_path = path.strip_prefix(base_path).unwrap();
    relative_path.to_string_lossy().to_string()
}

fn dump_path(path: PathBuf) -> Result<String> {
    let mut result = vec![];
    match std::fs::File::open(&path) {
        Err(e) => Err(GixorError::IO(e)),
        Ok(file) => {
            let reader = std::io::BufReader::new(file);
            for line in reader.lines() {
                result.push(line.unwrap());
            }
            Ok(result.join("\n"))
        }
    }
}

pub struct Gixor {
    pub(crate) config: Config,
    pub(crate) load_from: PathBuf,
}

impl Default for Gixor {
    fn default() -> Self {
        match dirs::config_dir() {
            Some(dir) => {
                let repositories = vec![default_repository()];
                let config = Config {
                    repositories,
                    base_path: dir.join("gixor").join("boilerplates"),
                };
                Self {
                    config,
                    load_from: dir.join("gixor").join("config.json"),
                }
            }
            None => panic!("Failed to get the config directory"),
        }
    }
}

impl Gixor {
    /// load the configuration file from the location.
    /// If not exists, return the default configuration by [`Gixor::default`].
    /// The default location is as follows.
    /// - Linux: `$XDG_CONFIG_HOME/gixor/config.json` or `$HOME/.config/gixor/config.json`
    /// - macOS: `$HOME/Library/Application Support/gixor/config.json`
    /// - Windows: `{FOLDERID_RoamingAppData}\gixor\config.json`
    pub fn load_or_default() -> Self {
        match dirs::config_dir() {
            Some(dir) => {
                let path = dir.join("gixor").join("config.json");
                match Gixor::load(path) {
                    Ok(s) => return s,
                    Err(_) => Gixor::default(),
                }
            }
            None => panic!("Failed to get the config directory"),
        }
    }

    pub fn is_empty(&self) -> bool {
        self.config.repositories.is_empty()
    }

    pub fn base_path(&self) -> &Path {
        &self.config.base_path
    }

    /// Parse the configuration file from the given path.
    pub fn load<P: AsRef<Path>>(path: P) -> Result<Self> {
        let path = path.as_ref();
        match std::fs::File::open(path) {
            Err(e) => Err(GixorError::IO(e)),
            Ok(f) => match serde_json::from_reader(f) {
                Ok(config) => Ok(Self {
                    config,
                    load_from: path.to_path_buf(),
                }),
                Err(e) => Err(GixorError::Json(e)),
            },
        }
    }

    /// Store the configuration to the configuration path.
    pub fn store(&self) -> Result<()> {
        match std::fs::File::create(&self.load_from) {
            Err(e) => Err(GixorError::IO(e)),
            Ok(f) => match serde_json::to_writer(f, &self.config) {
                Err(e) => Err(GixorError::Json(e)),
                Ok(_) => Ok(()),
            },
        }
    }

    pub fn repository<N: AsRef<str>>(&self, name: N) -> Option<&Repository> {
        let name = name.as_ref();
        self.config
            .repositories
            .iter()
            .find(|repo| repo.name == name)
    }

    /// Iterate the repositories in the configuration.
    pub fn repositories(&self) -> impl Iterator<Item = &Repository> {
        self.config.repositories.iter()
    }

    /// Iterate the boilerplate paths in the configuration.
    pub fn iter<'a>(&'a self) -> impl Iterator<Item = PathBuf> + 'a {
        self.config.iter()
    }

    /// Find the boilerplate by the name.
    pub fn find<S: AsRef<str>>(&self, name: S) -> Option<PathBuf> {
        self.config.find(name).map(|(path, _)| path)
    }

    /// Return the boilerplate by the name.
    pub fn dump<N: AsRef<str>>(&self, name: N) -> Option<Boilerplate> {
        let name = name.as_ref().to_string();
        if let Some((path, repo)) = self.config.find(name.clone()) {
            Some(Boilerplate::new(name, path, repo, self.base_path()))
        } else {
            None
        }
    }

    /// Update the all of boilerplate repositories.
    pub fn update_all(&self, _force: bool) -> Result<()> {
        let mut errs = vec![];
        for repo in &self.config.repositories {
            match self.update_repository(repo) {
                Err(e) => errs.push(e),
                Ok(_) => (),
            }
        }
        utils::errs_vec_to_result(errs, ())
    }

    pub fn add_repository(&self, repo: Repository) -> Result<Gixor> {
        match self.clone_repository(&repo) {
            Err(e) => Err(e),
            Ok(_) => {
                let mut repos = self.config.repositories.clone();
                repos.push(repo);
                Ok(Gixor {
                    config: crate::Config {
                        repositories: repos,
                        base_path: self.config.base_path.clone(),
                    },
                    load_from: self.load_from.clone(),
                })
            }
        }
    }

    pub fn add_repository_of<S: AsRef<str>>(&self, url: S) -> Result<Gixor> {
        let repo = Repository::new(url);
        self.add_repository(repo)
    }

    pub fn remove_repository_with<S: AsRef<str>>(
        &self,
        name: S,
        keep_repo_dir: bool,
    ) -> Result<Gixor> {
        let name = name.as_ref();
        let mut repos = self.config.repositories.clone();
        let index = repos.iter().position(|repo| repo.name == name);
        if let Some(index) = index {
            let repo = repos.remove(index);
            if !keep_repo_dir {
                if let Err(e) = remove_repo_dir(&self.config.base_path, repo) {
                    return Err(e);
                }
            }
            Ok(Gixor {
                config: crate::Config {
                    repositories: repos,
                    base_path: self.config.base_path.clone(),
                },
                load_from: self.load_from.clone(),
            })
        } else {
            Err(GixorError::Fatal(format!("{}: repository not found", name)))
        }
    }

    pub fn clone_all(&self) -> Result<()> {
        let mut errs = vec![];
        for repo in self.repositories() {
            if let Err(e) = self.clone_repository(repo) {
                errs.push(e);
            }
        }
        utils::errs_vec_to_result(errs, ())
    }

    pub fn remove_repository<S: AsRef<str>>(&self, name: S) -> Result<Gixor> {
        self.remove_repository_with(name, false)
    }

    fn update_repository(&self, repo: &Repository) -> Result<()> {
        let path = self.config.base_path.join(&repo.path);
        let dot_git = path.join(".git");
        if path.exists() {
            if dot_git.exists() {
                match git::pull(&path, "origin", "main") {
                    Ok(_) => Ok(()),
                    Err(e) => Err(GixorError::Git(e)),
                }
            } else {
                Err(GixorError::Fatal(format!(
                    "{}: The repository is not a git repository",
                    path.display()
                )))
            }
        } else {
            self.clone_repository(repo)
        }
    }

    fn clone_repository(&self, repo: &Repository) -> Result<()> {
        let path = self.config.base_path.join(&repo.path);
        if path.exists() {
            log::trace!("The repository \"{}\" exists: {}", repo.url, path.display());
            return Ok(());
        }
        log::info!(
            "Cloning the repository: {} into {}",
            repo.url,
            path.display()
        );
        match git2::Repository::clone(&repo.url, &path) {
            Err(e) => Err(crate::GixorError::Git(e)),
            Ok(_) => Ok(()),
        }
    }
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "kebab-case")]
pub(crate) struct Config {
    pub(crate) repositories: Vec<Repository>,
    pub(crate) base_path: PathBuf,
}

impl Config {
    fn find<S: AsRef<str>>(&self, name: S) -> Option<(PathBuf, &Repository)> {
        let name = name.as_ref();
        for repo in &self.repositories {
            if let Some(path) = repo.find(name, &self.base_path) {
                return Some((path, repo));
            }
        }
        None
    }

    fn iter<'a>(&'a self) -> impl Iterator<Item = PathBuf> + 'a {
        self.repositories
            .iter()
            .flat_map(move |repo| repo.iter(&self.base_path))
    }
}

pub fn default_repository() -> Repository {
    Repository {
        name: "default".to_string(),
        url: "https://github.com/github/gitignore.git".to_string(),
        repo_name: "gitignore".to_string(),
        owner: "github".to_string(),
        path: PathBuf::from("default"),
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "kebab-case")]
pub struct Repository {
    pub name: String,
    pub url: String,
    pub repo_name: String,
    pub owner: String,
    pub path: PathBuf,
}

impl Repository {
    pub fn new<S: AsRef<str>>(url: S) -> Self {
        let url = url.as_ref();
        let (owner, repo_name) = url_to_name(url);
        let path = PathBuf::from(owner.clone());
        Self {
            name: owner.clone(),
            url: url.to_string(),
            repo_name,
            owner,
            path,
        }
    }

    pub fn new_with<S: AsRef<str>>(name: S, url: S) -> Self {
        let (owner, repo_name) = url_to_name(url.as_ref());
        let path = PathBuf::from(owner.clone());
        Self {
            name: name.as_ref().to_string(),
            url: url.as_ref().to_string(),
            repo_name,
            owner,
            path,
        }
    }

    pub fn new_with_path<S: AsRef<str>, P: AsRef<Path>>(name: S, url: S, path: P) -> Self {
        let (owner, repo_name_) = url_to_name(url.as_ref());
        Self {
            name: name.as_ref().to_string(),
            url: url.as_ref().to_string(),
            owner: owner,
            repo_name: repo_name_,
            path: path.as_ref().to_path_buf(),
        }
    }

    pub fn hash<P: AsRef<Path>>(&self, base_path: P) -> Result<Vec<u8>> {
        let path = base_path.as_ref().join(&self.path);
        let gitrepo = match git2::Repository::open(path) {
            Ok(repo) => repo,
            Err(_) => {
                return Err(GixorError::Git(git2::Error::from_str(
                    format!(
                        "{}: Failed to open the repository",
                        self.path.to_string_lossy().to_string()
                    )
                    .as_str(),
                )))
            }
        };
        let head = gitrepo.head();
        match head {
            Ok(head) => match head.peel_to_commit() {
                Ok(commit) => Ok(commit.id().as_bytes().to_vec()),
                Err(e) => Err(GixorError::Git(e)),
            },
            Err(_) => Err(GixorError::Git(git2::Error::from_str(
                "Failed to get the HEAD",
            ))),
        }
    }

    pub fn find<S: AsRef<str>, P: AsRef<Path>>(&self, name: S, base_path: P) -> Option<PathBuf> {
        let name = name.as_ref().to_lowercase();
        for path in self.iter(base_path) {
            let fname = path.file_name().unwrap();
            if fname.to_string_lossy().to_lowercase().contains(&name) {
                return Some(path);
            }
        }
        None
    }

    /// Iterate the boilerplate paths in the repository.
    pub fn iter<P: AsRef<Path>>(&self, base_path: P) -> impl Iterator<Item = PathBuf> {
        ignore::WalkBuilder::new(base_path.as_ref().join(&self.path))
            .standard_filters(true)
            .build()
            .flatten()
            .map(|entry| entry.into_path())
            .filter(|p| is_gitignore_file(p.file_name()))
    }
}

fn is_gitignore_file(name: Option<&std::ffi::OsStr>) -> bool {
    if let Some(name) = name.unwrap().to_str() {
        name.ends_with(".gitignore")
    } else {
        false
    }
}

fn url_to_name(url: &str) -> (String, String) {
    let items = url.split('/').collect::<Vec<_>>();
    match (items.get(items.len() - 2), items.get(items.len() - 1)) {
        (Some(&owner), Some(&name)) => (owner.into(), strip_dot_git(name)),
        (None, Some(&name)) => ("unknown".into(), strip_dot_git(name)),
        (Some(&owner), None) => (owner.to_string(), "gitignore".into()),
        _ => ("unknown".into(), "gitignore".into()),
    }
}

fn strip_dot_git<S: AsRef<str>>(s: S) -> String {
    let s = s.as_ref().to_string();
    if let Some(name) = s.strip_suffix(".git") {
        name.to_string()
    } else {
        s.to_string()
    }
}

fn remove_repo_dir<P: AsRef<Path>>(base_path: P, repo: Repository) -> Result<()> {
    let path = base_path.as_ref().join(repo.path);
    match std::fs::remove_dir_all(&path) {
        Err(e) => Err(GixorError::IO(e)),
        Ok(_) => Ok(()),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_url_to_name() {
        let url = "https://github.com/github/gitignore.git";
        let (owner, name) = url_to_name(url);
        assert_eq!(owner, "github");
        assert_eq!(name, "gitignore");
    }

    #[test]
    fn parse_gixor() {
        match Gixor::load(PathBuf::from("testdata/config.json")) {
            Err(e) => panic!("Failed to parse the config file: {}", e),
            Ok(gixor) => {
                assert_eq!(
                    gixor.config.base_path,
                    PathBuf::from("testdata/boilerplates")
                );
                assert_eq!(gixor.config.repositories.len(), 2);
            }
        }
    }

    #[test]
    fn test_repo() {
        let repo =
            Repository::new_with_path("tamada", "git@github.com:tamada/gitignore.git", "tamada");
        assert_eq!(repo.name, "tamada");
        assert_eq!(repo.url, "git@github.com:tamada/gitignore.git");
        assert_eq!(repo.path, PathBuf::from("tamada"));

        let base_path = PathBuf::from("testdata/boilerplates");
        let boilerplates = repo.iter(&base_path).collect::<Vec<_>>();
        assert_eq!(boilerplates.len(), 1);

        if let Some(path) = repo.find("devcontainer", &base_path) {
            assert_eq!(path, base_path.join("tamada/devcontainer.gitignore"));
        } else {
            panic!("Failed to find the devcontainer.gitignore");
        }
    }
}
